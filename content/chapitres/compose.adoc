= 🐋🐙 Docker compose

image::2073552164-image2.png[height=550px]

== 🌐🏡 Un cas de la vraie vie

Une application riche repose souvent sur plusieurs éléments techniques à coordonner ensemble.

(Apache, Tomcat, Node, MongoDB, ElasticSearch, Logstash, etc.)

Comment automatiser ces déploiements ?

[%autoanimate]
== 📜💻 On pourrait tout scripter…

[source,bash]
----
include::../code-samples/compose/script.sh[]
----

[%autoanimate]
== 📜💻 Tout scripter

image::351794078-image3.gif[]

[%step]
- Et tout lancer indépendamment ?
- Et tout monitorer un par un ?
- Peut mieux faire, non ?

[%autoanimate]
== 🐋🐙 docker compose.yml

[source,yaml]
----
services:
----
[%autoanimate]
== 🐋🐙 docker compose.yml

[source,yaml]
----
services:
  apache:

          
               
                
                            
            
                                                                         
  middle:
            
                
                  
  db:
----

[%autoanimate]
== 🐋🐙 docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
          
               
                
                            
            
                                                                         
  middle:
            
                
                  
  db:
----
[%autoanimate]
== 🐋🐙 docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
                
                            
            
                                                                         
  middle:
            
                
                  
  db:
----

[%autoanimate]
== 🐋🐙 docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
            
                                                                         
  middle:
            
                
                  
  db:
----

[%autoanimate]
== 🐋🐙 docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
            
                
                  
  db:

----
[%autoanimate]
== 🐋🐙 docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
    build: .
                
                  
  db:
----

[%autoanimate]
== 🐋🐙 docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
    build: .
    environment:
      - DB_HOST=db
  db:
----

[%autoanimate]
== 🐋🐙 docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
    build: .
    environment:
      - DB_HOST=db
  db:
    image: "mysql:5.6"
----

[%autoanimate]
== 🐋🐙 docker compose.yml

[source,yaml]
----
services:
  apache:
    image: "my-httpd:2.4"
    ports:
      - "80:80"
    environment:
      - MIDDLE_HOST_1=middle
    volumes:
      - ./etc/httpd/workers.properties:/etc/httpd/conf/workers.properties
  middle:
    build: .
    environment:
      - DB_HOST=db
  db:
    image: "mysql:5.6"
    ports:
      - "3306:3306"

----

[%auto-animate]
== 🤔➡️ Et après ?

[source,bash]
----
docker compose up -d
docker compose build
docker compose logs
docker compose stop
docker compose restart
docker compose down
----

[%auto-animate]
== 🏁🔢 Ordre de démarrage

L'ordre de démarrage fait référence à la séquence dans laquelle les services définis dans un fichier Docker Compose sont lancés.

[%auto-animate]
== 🏁🔢 Ordre de démarrage

[.title]
Pourquoi est-ce important ?
[%step]
Certains services peuvent dépendre d'autres services pour fonctionner correctement.
[%step]
Par exemple, une application web peut avoir besoin qu'une base de données soit opérationnelle avant de pouvoir démarrer.

[%auto-animate]
== 🏁🔢 Ordre de démarrage

[.title]
Comment Docker Compose gère-t-il l'ordre de démarrage ?
[%step]
Par défaut, Docker Compose démarre les services dans l'ordre dans lequel ils sont définis dans le fichier Docker Compose.
[%step]
Cependant, cela ne garantit pas que les services dépendants seront prêts à être utilisés lorsque les services qui en dépendent seront lancés.

[%auto-animate]
== 🏁🔢 Ordre de démarrage

[.title]
Comment gérer les dépendances entre services ?
[%step]
Docker Compose offre deux directives pour gérer les dépendances entre services : `depends_on` et `healthcheck`.

[%step]
- `depends_on` : Cette directive peut être utilisée pour indiquer qu'un service dépend d'un autre service.
Cependant, cela ne garantit pas que le service dépendant sera prêt à être utilisé lorsque le service qui en dépend sera lancé.
- `healthcheck` : Cette directive peut être utilisée pour vérifier l'état de santé d'un service.
En combinaison avec `depends_on`, elle peut aider à s'assurer qu'un service est prêt à être utilisé avant de lancer les services qui en dépendent.

[%auto-animate]
== 🏁🔢 Ordre de démarrage

[.title]
Exemple
Voici un exemple de fichier Docker Compose qui utilise `depends_on` et `healthcheck` pour gérer l'ordre de démarrage des services :

[%step]
[source,yaml]
----
version: '3'
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_healthy
  db:
    image: postgres
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 30s
      timeout: 30s
      retries: 3
----

[%step]
Dans cet exemple, le service web dépend du service db.
Le service db est vérifié toutes les 30 secondes pour s'assurer qu'il est prêt à être utilisé.
Le service web ne sera lancé que lorsque le service db sera en bonne santé.

[%auto-animate]
== 🏁🔢 Ordre de démarrage❓🤔 Conditions.

WARNING: Rappel:
La directive `depends_on` dans un fichier Docker Compose est utilisée pour indiquer qu'un service dépend d'un autre service.
Cela signifie que le service dépendant ne sera pas démarré tant que les services dont il dépend n'auront pas été démarrés.

[%auto-animate]
== 🏁🔢 Ordre de démarrage❓🤔 Autres conditions.

En plus de la condition service_healthy, il existe d'autres conditions que vous pouvez utiliser avec `depends_on`:
[%step]
`service_started` : Cette condition signifie que le service dépendant ne sera pas démarré tant que le service dont il dépend n'aura pas été démarré.
[%step]
`service_completed_successfully`: Cette condition indique qu'un service dépendant ne doit pas démarrer avant qu'un autre service ait terminé avec succès. Cela peut être utile dans des scénarios où un service doit effectuer une tâche unique qui doit être terminée avant que d'autres services puissent débuter.
[%step]
Cependant, cela ne garantit pas que le service dont il dépend est prêt à être utilisé.

[%auto-animate]
== 🏁🔢 Ordre de démarrage❓🤔 Autre condition.

Voici un exemple de comment vous pourriez utiliser `service_started` dans un fichier Docker Compose :
[%step]
[source,yaml]
----
version: '3'
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_started
  db:
    image: postgres
----

[%step]
Dans cet exemple, le service `web` ne sera démarré que lorsque le service `db` aura été démarré.

[%auto-animate]
== 🏁🔢 Ordre de démarrage & 🩺✅ healthcheck

WARNING: Rappel
`healthcheck` est une instruction dans un `Dockerfile` qui permet de vérifier l'état de santé d'un service.
Il peut être utilisé pour déterminer si un service est prêt à être utilisé ou non.
[%step]
Voici un exemple de `healthcheck` dans un `Dockerfile` :
[%step]
[source,dockerfile]
----
FROM postgres
HEALTHCHECK --interval=5m --timeout=3s \
  CMD pg_isready -U postgres || exit 1
----
[%step]
Dans cet exemple, `pg_isready -U postgres` est la commande utilisée pour vérifier l'état de santé du service.
Si cette commande réussit, le service est considéré comme sain.
Sinon, il est considéré comme malsain.

[%auto-animate]
== 🏁🔢 Ordre de démarrage & 🩺✅ healthcheck
WARNING: Rappel
`depends_on` est une directive dans un fichier Docker Compose qui indique qu'un service dépend d'un autre service.
Il peut être utilisé pour contrôler l'ordre de démarrage des services.
[%step]
Voici un exemple de depends_on dans un fichier Docker Compose :
[%step]
[source,yaml]
----
version: '3'
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_healthy
  db:
    image: postgres
----
[%step]
Dans cet exemple, le service `web` dépend du service `db`.
Le service web ne sera démarré que lorsque le service db sera en bonne santé.

[%auto-animate]
== 🏁🔢 🩺✅ Comment healthcheck et depends_on travaillent ensemble ?
[.title]
En combinant `healthcheck` et `depends_on`, vous pouvez contrôler l'ordre de démarrage des services en fonction de leur état de santé.
Par exemple, vous pouvez vous assurer qu'un service de base de données est prêt à être utilisé avant de démarrer une application web qui en dépend.

[%auto-animate]
== 🏁🔢 Ordre de démarrage 📊📝 Pour résumer

L'ordre de démarrage fait référence à la séquence dans laquelle les services définis dans un fichier Docker Compose sont lancés.
Par défaut, Docker Compose démarre les services dans l'ordre dans lequel ils sont définis dans le fichier Docker Compose.

[%step]
Docker Compose offre deux directives pour gérer les dépendances entre services : `depends_on` et `healthcheck`.

[%auto-animate]
== 🏁🔢 Ordre de démarrage 📊📝 Pour résumer

- `depends_on` : Cette directive peut être utilisée pour indiquer qu'un service dépend d'un autre service. Elle peut être utilisée avec deux conditions : `service_started` et `service_healthy`.
- `service_started` : Cette condition signifie que le service dépendant ne sera pas démarré tant que le service dont il dépend n'aura pas été démarré. Cependant, cela ne garantit pas que le service dont il dépend est prêt à être utilisé.
- `service_healthy` : Cette condition est utilisée avec la directive healthcheck dans un Dockerfile pour vérifier l'état de santé d'un service. Si la commande healthcheck réussit, Docker considère le service comme sain. Sinon, il est considéré comme malsain.

[%auto-animate]
== 🏁🔢 Ordre de démarrage 📊📝 Pour résumer
[.title]
Exemple
Voici un exemple de fichier Docker Compose qui utilise depends_on et healthcheck pour gérer l'ordre de démarrage des services :
[%step]
[source,yaml]
----
version: '3'
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_healthy
  db:
    image: postgres
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 30s
      timeout: 30s
      retries: 3
----

[%auto-animate]
== 🏁🔢 Étude de cas 📚🔍

Un exemple de fichier docker-compose.yml utilisé dans Jenkins:

https://raw.githubusercontent.com/ash-sxn/GSoC-2023-docker-based-quickstart/main/docker-compose.yaml

[source,yaml]
----
sidekick_service:
    # Configuration for the sidekick service
    image: ${DOCKERHUB_USERNAME}/jenkinsci-tutorials:sidekick_
    stdin_open: true
    tty: true
    entrypoint: sh -c "/usr/local/bin/keygen.sh /ssh-dir"  # Runs the keygen.sh script and specifies the output directory
    volumes:
      - agent-ssh-dir:/ssh-dir  # Mounts the agent-ssh-dir volume to the /ssh-dir path inside the container
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5
----
[%step]
Les options `stdin_open: true` et `tty: true` sont utilisées pour garder l'entrée standard du conteneur ouverte et pour allouer un pseudo-TTY au conteneur, respectivement.
C'est généralement fait lorsque vous voulez interagir avec le service en cours d'exécution.

[%auto-animate]
== 🏁🔢 Étude de cas 📚🔍

[source,yaml]
----
sidekick_service:
    # Configuration for the sidekick service
    image: ${DOCKERHUB_USERNAME}/jenkinsci-tutorials:sidekick_
    stdin_open: true
    tty: true
    entrypoint: sh -c "/usr/local/bin/keygen.sh /ssh-dir"  # Runs the keygen.sh script and specifies the output directory
    volumes:
      - agent-ssh-dir:/ssh-dir  # Mounts the agent-ssh-dir volume to the /ssh-dir path inside the container
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5
----

-  La directive `entrypoint` est utilisée pour spécifier la commande qui sera exécutée lorsque le conteneur démarre.
- Dans ce cas, elle exécute une commande shell qui exécute un script nommé `keygen.sh` situé à `/usr/local/bin/keygen.sh`.
- Le script reçoit un argument `/ssh-dir`, qui est le répertoire où le script effectuera ses opérations.

[%auto-animate]
== 🏁🔢 Étude de cas 📚🔍

[source,yaml]
----
sidekick_service:
    # Configuration for the sidekick service
    image: ${DOCKERHUB_USERNAME}/jenkinsci-tutorials:sidekick_
    stdin_open: true
    tty: true
    entrypoint: sh -c "/usr/local/bin/keygen.sh /ssh-dir"  # Runs the keygen.sh script and specifies the output directory
    volumes:
      - agent-ssh-dir:/ssh-dir  # Mounts the agent-ssh-dir volume to the /ssh-dir path inside the container
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5
----
[%step]
* La directive volumes est utilisée pour monter un volume nommé `agent-ssh-dir` sur le chemin `/ssh-dir` à l'intérieur du conteneur.
* Cela permet de conserver les données entre les redémarrages du conteneur et peut également être utilisé pour partager des données entre les conteneurs.

[%auto-animate]
== 🏁🔢 Étude de cas 📚🔍

[source,yaml]
----
sidekick_service:
    # Configuration for the sidekick service
    image: ${DOCKERHUB_USERNAME}/jenkinsci-tutorials:sidekick_
    stdin_open: true
    tty: true
    entrypoint: sh -c "/usr/local/bin/keygen.sh /ssh-dir"  # Runs the keygen.sh script and specifies the output directory
    volumes:
      - agent-ssh-dir:/ssh-dir  # Mounts the agent-ssh-dir volume to the /ssh-dir path inside the container
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5
----
[%step]
* Enfin, un healthcheck est défini pour le service. Il s'agit d'une commande que Docker exécutera à l'intérieur du conteneur pour vérifier sa santé.
* Dans ce cas, la commande vérifie si un fichier nommé `conductor_ok` existe dans le répertoire `/ssh-dir`.
* Si le fichier existe, la commande réussit et Docker considère le service comme sain.
* Si le fichier n'existe pas, la commande échoue et Docker considère le service comme malsain.
* Docker exécutera cette vérification de santé toutes les 5 secondes (`interval: 5s`), et si elle ne répond pas dans les 10 secondes (`timeout: 10s`), Docker la considérera comme un échec. Docker réessaiera une vérification de santé échouée 5 fois (`retries: 5`) avant de considérer le service comme malsain.

[%auto-animate]
[.columns]
== 🏁🔢 Étude de cas 📚🔍

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
* Service jenkins_controller
[%step]
** Ce service dépend du `sidekick_service`.
** Il ne démarrera que lorsque le `sidekick_service` aura terminé avec succès.
** C'est ce que signifie la condition `service_completed_successfully`.
--


[%auto-animate]
[.columns]
== 🏁🔢 Étude de cas 📚🔍

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
Un `healthcheck` est également défini pour ce service.
[%step]
* Docker vérifie si un fichier nommé `conductor_ok` existe dans le chemin `/ssh-dir`.
* Si le fichier existe, Docker considère le service comme sain.
* Sinon, il est considéré comme malsain.
--


[%auto-animate]
[.columns]
== 🏁🔢 Étude de cas 📚🔍

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
Service `default_agent`
[%step]
* Ce service dépend également du `sidekick_service` et du `jenkins_controller`.
* Il ne démarrera que lorsque le `sidekick_service` aura terminé avec succès et que le `jenkins_controller` aura démarré.
* C'est ce que signifient les conditions `service_completed_successfully` et `service_started`.
--

[%auto-animate]
[.columns]
== 🏁🔢 Étude de cas 📚🔍

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
Un `healthcheck` est également défini pour ce service.
[%step]
* Docker vérifie si un fichier nommé `authorized_keys` existe dans le chemin `/home/jenkins/.ssh`.
* Si le fichier existe, Docker considère le service comme sain.
* Sinon, il est considéré comme malsain.
--

[%auto-animate]
[.columns]
== 🏁🔢 Étude de cas 📚🔍

[.column.is-two-thirds]
--
[source,yaml]
----
services:
  sidekick_service: [...]

  jenkins_controller: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /ssh-dir/conductor_ok ] || exit 1" ]  # Checks if the conductor_ok file exists in the /ssh-dir path
      interval: 5s
      timeout: 10s
      retries: 5

  default_agent: [...]
    depends_on:
      sidekick_service:
        condition: service_completed_successfully  # Depends on the successful completion of the sidekick_service
      jenkins_controller:
        condition: service_started
    healthcheck:
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Checks if the authorized_keys file exists in the /home/jenkins/.ssh path
      interval: 5s
      timeout: 10s
      retries: 5
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Mounts the agent-ssh-dir volume to the /home/jenkins/.ssh path inside the container as read-only
----
--

[.column]
--
Enfin, un volume nommé `agent-ssh-dir` est monté sur le chemin `/home/jenkins/.ssh` à l'intérieur du conteneur en lecture seule.
--

[%auto-animate]
== 🏁🔢 Étude de cas 📚🔍

À étudier au calme chez vous:

https://raw.githubusercontent.com/gounthar/MyFirstAndroidAppBuiltByJenkins/stf/jenkins/docker-compose.yml

image::47642838-image4.png[]

[.notes]
--
Dans le temps, on recommandait de faire un script qui attendait que le service soit démarré avant de continuer.
https://github.com/vishnubob/wait-for-it
--

== Transformer son application en docker compose

Deux approches différentes et complémentaires :
[%step]
* https://www.composerize.com/
* https://github.com/jwilder/dockerize

== 🎓 Travaux pratiques #12

image::497269344-image5.png[]

https://gitlab.univ-artois.fr/bruno.verachten/devops-docker-tp12.git

[%auto-animate]
== 🎓 Travaux pratiques #12-BIS 🔨🔥

Ça vous dirait d'avoir votre propre forge Gitlab ?
[%step]
😏 Non, et bien c'est parti quand même.
[%step]
* Créez un nouveau fichier appelé `docker-compose.yml`.
* Dans ce fichier, définissez trois services : `gitlab`, `gitlab-runner-1` et `gitlab-runner-2`.
* Pour le service `gitlab`:
** utilisez l'image `gitlab/gitlab-ce:latest` (préfixée par le cache spécifique ILI)
** redémarrez toujours le conteneur s'il s'arrête,
** définissez le nom d'hôte sur `localhost`,
** définissez l'URL externe sur `http://localhost` et exposez les ports `80`, `443` et `22`.

[%auto-animate]
== 🎓 Travaux pratiques #12-BIS
[%step]
* Pour les services gitlab-runner-1 et gitlab-runner-2:
[%step]
** utilisez l'image `gitlab/gitlab-runner:latest` (préfixée par le cache spécifique ILI),
** redémarrez toujours le conteneur s'il s'arrête,
** dépendez du service gitlab et montez le socket Docker et le fichier de configuration de GitLab Runner.
[%step]
* Créez des volumes pour:
[%step]
** les fichiers de configuration,
** les fichiers journaux
** et les fichiers de données de GitLab,
** ainsi que pour les fichiers de configuration de GitLab Runner.

[%auto-animate]
== 🎓 Travaux pratiques #12-BIS 🔨🔥

Pas assez détaillé? 😨
[%step]
* Ouvrez votre éditeur de texte préféré et créez un nouveau fichier.
* Nommez ce fichier `docker-compose.yml`.
* Commencez le fichier avec la ligne `services:` pour commencer à définir les services de votre application.
* Commencez à définir votre premier service en tapant `gitlab:` sur une nouvelle ligne. Ce sera le service pour votre serveur GitLab.
* Sous `gitlab:`, ajoutez les détails de votre service.
[%step]
** Par exemple, `image: 'gitlab/gitlab-ce:latest'` pour spécifier l'image Docker à utiliser pour ce service.

[%auto-animate]
== 🎓 Travaux pratiques #12-BIS 🔨🔥

* Sous `gitlab:`, ajoutez les détails de votre service.
** Par exemple, `image: 'gitlab/gitlab-ce:latest'` pour spécifier l'image Docker à utiliser pour ce service.
** Continuez à ajouter des détails pour le service gitlab, comme `restart: always` pour toujours redémarrer le conteneur s'il s'arrête, et `hostname: 'localhost'` pour définir le nom d'hôte du serveur GitLab.
[%step]
* Définissez l'URL externe de votre serveur GitLab en ajoutant `environment:` et `GITLAB_OMNIBUS_CONFIG: |` sur de nouvelles lignes,
* puis `external_url 'http://localhost'` sur la ligne suivante.
* Exposez les ports nécessaires en ajoutant `ports:` sur une nouvelle ligne,
* puis `- '80:80'`, `- '443:443'` et `- '22:22'` sur les lignes suivantes.


[%auto-animate]
== 🎓 Travaux pratiques #12-BIS 🔨🔥

[%step]
* Montez les volumes nécessaires en ajoutant `volumes:` sur une nouvelle ligne,
[%step]
** puis `- 'gitlab_config:/etc/gitlab'`,
** `- 'gitlab_logs:/var/log/gitlab'`
** et `- 'gitlab_data:/var/opt/gitlab'` sur les lignes suivantes.
[%step]
* Répétez ces étapes pour les services gitlab-runner-1 et gitlab-runner-2, en remplaçant `gitlab` par `gitlab-runner-1` et `gitlab-runner-2` respectivement.


[%auto-animate]
== 🎓 Travaux pratiques #12-BIS 🔨🔥

[%step]
* Pour les services `gitlab-runner-1` et `gitlab-runner-2`, remplacez l'URL externe par une dépendance au service gitlab en ajoutant `depends_on:` sur une nouvelle ligne, puis `- gitlab` sur la ligne suivante.
* Montez le socket Docker et le fichier de configuration de GitLab Runner
[%step]
** en ajoutant `- '/var/run/docker.sock:/var/run/docker.sock'`
** et `- 'gitlab-runner-1-config:/etc/gitlab-runner'` (ou `- 'gitlab-runner-2-config:/etc/gitlab-runner'` pour `gitlab-runner-2`) sous `volumes:`.

[%auto-animate]
== 🎓 Travaux pratiques #12-BIS 🔨🔥

[%step]
Enfin, définissez les volumes pour votre application en ajoutant `volumes:` sur une nouvelle ligne à la fin de votre fichier, puis
[%step]
** `- gitlab_config:`,
** `- gitlab_logs:`,
** `- gitlab_data:`,
** `- gitlab-runner-1-config:`
** et `- gitlab-runner-2-config:` sur les lignes suivantes.

== ✅ Solution Travaux pratiques #12-BIS 🔨🔥

[source,yaml]
----
include::../code-samples/compose/tp12-bis.yml[]
----

[%auto-animate]
[.columns]
== 🔨🔥 J'ai ma forge! Bon, et maintenant? 😐

[.column]
image::when.png[height=500px]
[.column]
video::gitlab-logs.speed.very.small.mp4[height=500px,options=autoplay,loop,nocontrols]

[%auto-animate]
[background-video="2000_years_later.mp4",background-video-loop=true,background-video-muted=true]
[.intellij.background]
== 🔨🔥 J'ai ma forge! Bon, et maintenant? 😐

Il va falloir se logguer, lier les runners au serveur, créer un projet, etc...

[%auto-animate]
[.columns]
== 🔨🔥 J'ai ma forge! Bon, et maintenant? 😐

[.column]
image::gitlab-login.png[height=500px]

[.column]
--
Pour trouver le mot de passe, il va falloir le demander gentiment à Gitlab:

[source,bash]
----
docker compose -f tp12-bis.yml exec -it gitlab grep 'Password:' /etc/gitlab/initial_root_
password
Password: qaPxXU+RqioolV3bAljvs2VYnyYa4jO/UYcis/UXLAk=
----
[%step]
Ensuite, il va falloir restreindre l'accès:
[%step]
image::sign-up-restrictions.png[]
--

[%auto-animate]
== 🔨🔥 J'ai ma forge! Bon, et maintenant? 😐
- Pour utiliser le runner GitLab dans GitLab, vous devez le configurer.
[%step]
- Pour une configuration correcte, nous aurons besoin d'un jeton copié depuis le portail.
- Pire que ça, pas un jeton, mais carrément une commande à adapter à `docker compose`.
- Pour ce faire, allez à l'adresse : http://localhost/admin/runners et cliquez sur le bouton "New instance runner".
- Choisissez "Linux".
- "Run untagged jobs"
- Donnez une description au runner.
- Cliquez sur le bouton "Create runner"
- Vous avez ensuite une commande à copier et modifier pour `docker compose`.


[%auto-animate]
[%notitle,background-iframe="https://www.youtube.com/embed/S-npLuur6KM?rel=0&start=0&enablejsapi=1&autoplay=1&loop=1&controls=1&modestbranding=1"]
== 🔨🔥 J'ai ma forge! Bon, et maintenant? 😐

[.notes]
--
https://youtu.be/S-npLuur6KM
--

[%auto-animate]
== 🔨🔥 J'ai ma forge! Bon, et maintenant? 😐

[source,bash]
----
docker compose -f tp12-bis.yml exec gitlab-runner-1 gitlab-runner register --url http://gitlab  --token glrt-PF5rLbUKzku5g8BL2y7J
Runtime platform                                    arch=amd64 os=linux pid=103 revision=853330f9 version=16.5.0
Running in system-mode.

Enter the GitLab instance URL (for example, https://gitlab.com/):
[http://gitlab]:
Verifying runner... is valid                        runner=PF5rLbUKz
Enter a name for the runner. This is stored only in the local config.toml file:
[3c2ee0d97d2b]: runner 1
Enter an executor: parallels, docker-autoscaler, docker+machine, custom, docker, docker-windows, shell, ssh, virtualbox, instance, kubernetes:
shell
Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded!

Configuration (with the authentication token) was saved in "/etc/gitlab-runner/config.toml"
----

[%auto-animate]
== 👤 Profils dans Docker Compose 🐙
On a vu déjà l'instruction `depends_on` dans un fichier Docker Compose.
[%step]
- Elle permet de définir des dépendances entre les services.
- Mais que faire si on veut définir un lot de services qui fonctionnent ensemble, sans pour autant être en interdépendance ?
- Les profils dans Docker Compose permettent de définir des groupes de services qui peuvent être activés ou désactivés ensemble.
- Cela peut être utile pour gérer des environnements de développement, de test et de production différents dans le même fichier Docker Compose.
- Pour définir un profil pour un service, vous pouvez ajouter la clé `profiles` à la définition du service dans votre fichier Docker Compose.

[%auto-animate]
== 👤 Profils dans Docker Compose 🐙
Par exemple :

[%step]
[source,yaml]
----
services:
  mon_service:
    image: mon_image
    profiles:
      - dev
----
[%step]
Dans cet exemple, le service mon_service appartient au profil dev.

[%auto-animate]
== 👤 Profils dans Docker Compose 🐙

[%step]
- Pour démarrer seulement les services qui appartiennent à un certain profil, vous pouvez utiliser l'option `--profile` avec la commande `docker-compose up`.
- Par exemple :

[%step]
[source,bash]
----
docker-compose up --profile dev
----
[%step]
Cette commande démarrera seulement les services qui appartiennent au profil `dev`.

[%auto-animate]
== 👤 Profils dans Docker Compose 🐙

[%step]
- Les profils peuvent rendre votre fichier Docker Compose plus organisé et flexible.
- Ils vous permettent de définir différents environnements dans le même fichier et de choisir facilement quels services démarrer en fonction de vos besoins.
- Jetons un coup d'œil à un exemple de fichier Docker Compose avec des profils :

[%step]
[source,yaml]
----
services:
  service_dev:
    image: mon_image_dev
    profiles:
      - dev
  service_prod:
    image: mon_image_prod
    profiles:
      - prod
----
[%step]
- Dans cet exemple, nous avons deux services : `service_dev` et `service_prod`.
- Chacun appartient à un profil différent.

[%auto-animate]
== 👤 Profils dans Docker Compose 🐙
[source,yaml]
----
services:
  service_dev:
    image: mon_image_dev
    profiles:
      - dev
  service_prod:
    image: mon_image_prod
    profiles:
      - prod
----
[%step]
- Nous pouvons choisir de démarrer seulement les services de développement avec `docker-compose up --profile dev`, ou uniquement les services de production avec `docker-compose up --profile prod`.
- Les profils dans Docker Compose sont un outil puissant pour gérer différents environnements dans le même fichier Docker Compose.
- Ils peuvent rendre votre développement et vos tests plus efficaces et organisés.

== 🔨🔥 Une autre forge, ça vous dit? 😐

[%step]
😏 Non, et bien, c'est parti quand même.
[%step]

https://raw.githubusercontent.com/ash-sxn/GSoC-2023-docker-based-quickstart/main/build-docker-compose.yaml
[%step]
[source,yaml]
----
include::../code-samples/compose/jenkins-docker-compose.yml[]
----

== 🔨🔥 Une autre forge, ça vous dit? 😐

Indigeste? 😨
[%step]
Ne relevons que les points importants:

[%step]
[source,yaml]
----
  # Le service maven est un agent Jenkins avec Maven et le JDK installés.
  maven:
    build: dockerfiles/maven/.  # Le Dockerfile pour construire l'image du service Maven.
    container_name: desktop-jenkins_agent-1  # Le nom du conteneur.
    profiles:
      - maven  # Les profils à appliquer au service. Cela permet de personnaliser le comportement du service en fonction des besoins spécifiques.
    depends_on:  # Les services dont ce service dépend.
      sidekick_service:
        condition: service_completed_successfully  # Le sidekick_service doit se terminer avec succès avant que ce service ne démarre.
      jenkins_controller:
        condition: service_started  # Le service jenkins_controller doit démarrer avant que ce service ne démarre.
    healthcheck:  # La commande de vérification de santé pour le service.
      test: [ "CMD-SHELL", "[ -f /home/jenkins/.ssh/authorized_keys ] || exit 1" ]  # Vérifie si le fichier authorized_keys existe dans le chemin /home/jenkins/.ssh.
      interval: 5s  # Le temps entre les vérifications de santé.
      timeout: 10s  # Le temps à attendre avant de considérer que la vérification a échoué.
      retries: 5  # Le nombre d'échecs consécutifs nécessaires pour considérer un service comme malsain.
    volumes:
      - agent-ssh-dir:/home/jenkins/.ssh:ro  # Monte le volume agent-ssh-dir au chemin /home/jenkins/.ssh à l'intérieur du conteneur en lecture seule.
----

== Autre étude de cas 📚🔍

Et pourquoi pas s'attaquer au docker-compose qui a généré ce cours ?
